// Emtpy main.c file generated by the wizard

#include "landing_buz.h"
#include "cutoff.h"
#include "gps.h"
#include "adc_mgr.h"
#include "sensors.h"
#include "logging.h"
#include "measures.h"
#include "hadarp.h"
#include "status_mgr.h"

#include "hw/hw_pin.h"
#include <cpu/irq.h>
#include <cfg/debug.h>

#include <kern/proc.h>
#include <kern/monitor.h>

#include <drv/timer.h>
#include <drv/buzzer.h>
#include <drv/ser.h>
#include <drv/kbd.h>
#include <drv/sd.h>
#include <drv/spi_dma_at91.h>

#include <mware/ini_reader.h>

#include <fs/fat.h>

#include <net/afsk.h>
#include <net/ax25.h>

#include <net/nmea.h>

#include <verstag.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define LOG_LEVEL LOG_LVL_INFO
#include <cfg/log.h>

static Afsk afsk;
static Serial ser;
static SpiDmaAt91 spi_dma;
static Sd sd;
static FATFS fs;
static AX25Ctx ax25;

INLINE void ledr(bool val)
{
	if (val)
		PIOA_SODR = LEDR;
	else
		PIOA_CODR = LEDR;
}

INLINE void ledg(bool val)
{
	if (val)
		PIOA_SODR = LEDG;
	else
		PIOA_CODR = LEDG;
}

static void ax25_log(struct AX25Msg *msg)
{
	logging_msg("%.*s\n", msg->len, msg->info);
	kprintf("%.*s\n", msg->len, msg->info);
}

static mtime_t aprs_interval;
static ticks_t log_interval;
static char send_call[7];

static void NORETURN radio_process(void)
{
	char msg[100];
	AX25Call path[2]=
	{
		AX25_CALL("APZBRT", 0),
	};
	memcpy(path[1].call, send_call, sizeof(path[1].call));
	path[1].ssid = 0;

	ticks_t start;
	while (1)
	{
		start = timer_clock();
		measures_aprsFormat(msg, sizeof(msg));

		for (int i = 0; i < 3; i++)
		{
			ax25_sendVia(&ax25, path, countof(path), msg, strlen(msg));
			timer_delay((i+1) * 2000);
		}

		/*
		 * We have already waited for some time here,
		 * take into account this difference.
		 * Also limit the minimum delay to 3 seconds, resulting in a new message
		 * about every 15 seconds.
		 */
		timer_delay(MAX((mtime_t)3000, aprs_interval - ticks_to_ms(timer_clock() - start)));
	}
}

static void init(void)
{
	IRQ_ENABLE;
	kdbg_init();
	kprintf("BSM-2, ver %s\n", vers_tag);
	timer_init();
	buz_init();
	proc_init();
	afsk_init(&afsk, ADC_RADIO_CH, 0);
	ax25_init(&ax25, &afsk.fd, ax25_log);

	#if GPS_ENABLED
		ser_init(&ser, GPS_PORT);
		ser_setbaudrate(&ser, 4800);
		gps_init(&ser.fd);
	#else
		(void)ser;
		#warning "GPS process disabled."
	#endif

	#if HADARP_ENABLED
		hadarp_init(HADARP_PORT, 9600);
	#else
		#warning "HADARP process disabled."
	#endif

	spi_dma_init(&spi_dma);
	spi_dma_setclock(20000000L);
	kbd_init();
	measures_init();

	PIOA_CODR = LEDR | LEDG;
	PIOA_PER = LEDR | LEDG;
	PIOA_OER = LEDR | LEDG;

	ledr(true);
	ASSERT(sd_init(&sd, &spi_dma.fd, false));
	ASSERT(f_mount(0, &fs) == FR_OK);
	FatFile conf;
	ASSERT(fatfile_open(&conf, "conf.ini", FA_OPEN_EXISTING | FA_READ) == FR_OK);

	char inibuf[64];
	if (ini_getString(&conf.fd, "system", "calibration_mode", "0", inibuf, sizeof(inibuf)) == 0)
	{
		if (atoi(inibuf) != 0)
		{
			kprintf("Entering calibration mode...\n");
			bool ledon = true;
			while (1)
			{
				ledg(ledon);
				ledr(ledon);
				ledon = !ledon;
				for (int i = 0; i < ADC_CHANNELS; i++)
				{
					uint16_t val = adc_mgr_read(i);
					kprintf("CH%d %d\n", i, val);
				}
				kputchar('\n');
				timer_delay(1000);
			}
		}
	}


	/* Set ADC sensor calibration */
	for (int i = 0; i < ADC_CHANNELS; i++)
	{
		char calib[16];
		SensorCalibrationSet set;

		snprintf(calib, sizeof(calib), "calib%02d", i);
		calib[sizeof(calib) - 1] = '\0';

		if (ini_getString(&conf.fd, calib, "p1x", "0", inibuf, sizeof(inibuf)) != 0)
			continue;
		set.p1.x = atoi(inibuf);

		if (ini_getString(&conf.fd, calib, "p1y", "0", inibuf, sizeof(inibuf)) != 0)
			continue;
		set.p1.y = atoi(inibuf) / 1000.0;

		if (ini_getString(&conf.fd, calib, "p2x", "1023", inibuf, sizeof(inibuf)) != 0)
			continue;
		set.p2.x = atoi(inibuf);

		if (ini_getString(&conf.fd, calib, "p2y", "1023", inibuf, sizeof(inibuf)) != 0)
			continue;
		set.p2.y = atoi(inibuf) / 1000.0;

		LOG_INFO("Calibration loaded for channel %d\n", i);
		sensor_setCalibration(i, set);
	}

	CutoffCfg cutoff_cfg;
	ini_getString(&conf.fd, "cutoff", "mission_timeout", "8400", inibuf, sizeof(inibuf));
	cutoff_cfg.mission_timeout = atoi(inibuf);
	ini_getString(&conf.fd, "cutoff", "delta_altitude", "500", inibuf, sizeof(inibuf));
	cutoff_cfg.delta_altitude = atoi(inibuf);
	ini_getString(&conf.fd, "cutoff", "altitude_timeout", "30", inibuf, sizeof(inibuf));
	cutoff_cfg.altitude_timeout = atoi(inibuf);
	ini_getString(&conf.fd, "cutoff", "start_latitude", "43606414", inibuf, sizeof(inibuf));
	cutoff_cfg.start_latitude = atoi(inibuf);
	ini_getString(&conf.fd, "cutoff", "start_longitude", "11311832", inibuf, sizeof(inibuf));
	cutoff_cfg.start_longitude = atoi(inibuf);
	ini_getString(&conf.fd, "cutoff", "dist_max_meters", "80000", inibuf, sizeof(inibuf));
	cutoff_cfg.dist_max_meters = atoi(inibuf);
	ini_getString(&conf.fd, "cutoff", "dist_timeout", "300", inibuf, sizeof(inibuf));
	cutoff_cfg.dist_timeout = atoi(inibuf);

	cutoff_init(&cutoff_cfg);

	StatusCfg status_cfg;
	ini_getString(&conf.fd, "status", "ground_alt", "1500", inibuf, sizeof(inibuf));
	status_cfg.ground_alt = atoi(inibuf);
	ini_getString(&conf.fd, "status", "landing_alt", "3600", inibuf, sizeof(inibuf));
	status_cfg.landing_alt = atoi(inibuf);
	ini_getString(&conf.fd, "status", "tropopause_alt", "12500", inibuf, sizeof(inibuf));
	status_cfg.tropopause_alt = atoi(inibuf);
	ini_getString(&conf.fd, "status", "rate_up", "2", inibuf, sizeof(inibuf));
	status_cfg.rate_up = atoi(inibuf);
	ini_getString(&conf.fd, "status", "rate_down", "-2", inibuf, sizeof(inibuf));
	status_cfg.rate_down = atoi(inibuf);

	status_init(&status_cfg);

	ini_getString(&conf.fd, "landing_buz", "buz_timeout", "9000", inibuf, sizeof(inibuf));
	uint32_t buz_timeout_seconds = atoi(inibuf);

	landing_buz_init(buz_timeout_seconds);

	ini_getString(&conf.fd, "logging", "aprs_interval", "60", inibuf, sizeof(inibuf));
	aprs_interval = atoi(inibuf) * 1000;
	ini_getString(&conf.fd, "logging", "log_interval", "3", inibuf, sizeof(inibuf));
	log_interval = ms_to_ticks(atoi(inibuf) * 1000);
	ini_getString(&conf.fd, "logging", "send_call", "STSP2", inibuf, sizeof(inibuf));
	strncpy(send_call, inibuf, sizeof(send_call));
	send_call[sizeof(send_call) - 1] = '\0';

	kfile_close(&conf.fd);

	logging_init();
	proc_new(radio_process, NULL, KERN_MINSTACKSIZE * 4, NULL);
	ledr(false);
}

int main(void)
{
	init();
	bool led_on = true;

	ticks_t log_start = timer_clock();
	while (1)
	{
		timer_delay(500);
		ax25_poll(&ax25);

		bool fix = gps_fixed();

		if (fix && led_on)
			ledg(true);
		else if (!fix && led_on)
			ledr(true);
		else
		{
			ledg(false);
			ledr(false);
		}

		led_on = !led_on;

		if (kbd_peek() & K_START)
		{
			ledg(true);
			ledr(true);
			status_missionStart();
			logging_rotate();
		}

		if (timer_clock() - log_start > log_interval)
		{
			char msg[100];
			log_start = timer_clock();
			monitor_report();

			measures_logFormat(msg, sizeof(msg));
			kprintf("%s\n", msg);
			logging_data("%s\n", msg);
		}
	}
	return 0;
}

