// Emtpy main.c file generated by the wizard

#include "landing.h"
#include "cutoff.h"
#include "gps.h"
#include "adc_mgr.h"
#include "sensors.h"
#include "logging.h"
#include "measures.h"

#include "hw/hw_pin.h"
#include <cpu/irq.h>
#include <cfg/debug.h>

#include <kern/proc.h>
#include <kern/monitor.h>

#include <drv/timer.h>
#include <drv/buzzer.h>
#include <drv/ser.h>
#include <drv/kbd.h>
#include <drv/sd.h>
#include <drv/spi_dma_at91.h>

#include <mware/ini_reader.h>

#include <fs/fat.h>

#include <net/afsk.h>
#include <net/ax25.h>

#include <net/nmea.h>

#include <verstag.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define LOG_LEVEL LOG_LVL_INFO
#include <cfg/log.h>

static Afsk afsk;
static Serial ser;
static SpiDmaAt91 spi_dma;
static Sd sd;
static FATFS fs;
static AX25Ctx ax25;

INLINE void ledr(bool val)
{
	if (val)
		PIOA_SODR = LEDR;
	else
		PIOA_CODR = LEDR;
}

INLINE void ledg(bool val)
{
	if (val)
		PIOA_SODR = LEDG;
	else
		PIOA_CODR = LEDG;
}

#ifdef DEMO_BOARD
	#warning "Compiling for demoboard!"
#endif


static void ax25_log(struct AX25Msg *msg)
{
	logging_msg("%.*s\n", msg->len, msg->info);
}

static ticks_t aprs_interval;
static ticks_t log_interval;
static char send_call[7];

#define AFSK_IN_CH 4

static void init(void)
{
	IRQ_ENABLE;
	kdbg_init();
	kprintf("BSM-2, ver %s\n", vers_tag);
	timer_init();
	buz_init();
	proc_init();
	afsk_init(&afsk, AFSK_IN_CH, 0);
	ax25_init(&ax25, &afsk.fd, ax25_log);
	ser_init(&ser, SER_UART0);
	ser_setbaudrate(&ser, 4800);
	spi_dma_init(&spi_dma);
	spi_dma_setclock(20000000L);
	gps_init(&ser.fd);
	kbd_init();

	PIOA_CODR = LEDR | LEDG;
	PIOA_PER = LEDR | LEDG;
	PIOA_OER = LEDR | LEDG;

	ledr(true);
	ASSERT(sd_init(&sd, &spi_dma.fd, false));
	ASSERT(f_mount(0, &fs) == FR_OK);
	FatFile conf;
	ASSERT(fatfile_open(&conf, "conf.ini", FA_OPEN_EXISTING | FA_READ) == FR_OK);

	char inibuf[64];

	/* Set ADC sensor calibration */
	for (int i = 0; i < ADC_CHANNELS; i++)
	{
		char calib[16];
		SensorCalibrationSet set;

		snprintf(calib, sizeof(calib), "calib%02d", i);
		calib[sizeof(calib) - 1] = '\0';

		if (ini_getString(&conf.fd, calib, "p1x", "0", inibuf, sizeof(inibuf)) != 0)
			continue;
		set.p1.x = atoi(inibuf);

		if (ini_getString(&conf.fd, calib, "p1y", "0", inibuf, sizeof(inibuf)) != 0)
			continue;
		set.p1.y = atoi(inibuf) / 1000.0;

		if (ini_getString(&conf.fd, calib, "p2x", "1023", inibuf, sizeof(inibuf)) != 0)
			continue;
		set.p2.x = atoi(inibuf);

		if (ini_getString(&conf.fd, calib, "p2y", "1023", inibuf, sizeof(inibuf)) != 0)
			continue;
		set.p2.y = atoi(inibuf) / 1000.0;

		LOG_INFO("Calibration loaded for channel %d", i);
		sensor_setCalibration(i, set);
	}

	ini_getString(&conf.fd, "cutoff", "mission_time", "8400", inibuf, sizeof(inibuf));
	uint32_t max_seconds = atoi(inibuf);
	ini_getString(&conf.fd, "cutoff", "delta_press", "100", inibuf, sizeof(inibuf));
	float delta_press = atoi(inibuf);
	ini_getString(&conf.fd, "cutoff", "delta_timeout", "60", inibuf, sizeof(inibuf));
	uint32_t delta_timeout = atoi(inibuf);
	ini_getString(&conf.fd, "cutoff", "base_lat", "43606414", inibuf, sizeof(inibuf));
	udegree_t base_lat = atoi(inibuf);
	ini_getString(&conf.fd, "cutoff", "base_lon", "11311832", inibuf, sizeof(inibuf));
	udegree_t base_lon = atoi(inibuf);
	ini_getString(&conf.fd, "cutoff", "max_dist", "80000", inibuf, sizeof(inibuf));
	uint32_t max_meters = atoi(inibuf);
	ini_getString(&conf.fd, "cutoff", "dist_timeout", "300", inibuf, sizeof(inibuf));
	uint32_t maxdist_timeout = atoi(inibuf);

	cutoff_init(max_seconds, delta_press, delta_timeout, base_lat, base_lon, max_meters, maxdist_timeout);

	ini_getString(&conf.fd, "landing", "landing_alt", "3600", inibuf, sizeof(inibuf));
	int32_t landing_meters = atoi(inibuf);
	ini_getString(&conf.fd, "landing", "count_limit", "20", inibuf, sizeof(inibuf));
	int count_limit = atoi(inibuf);
	ini_getString(&conf.fd, "landing", "buz_timeout", "9000", inibuf, sizeof(inibuf));
	uint32_t buz_timeout_seconds = atoi(inibuf);

	landing_init(landing_meters, count_limit, buz_timeout_seconds);

	ini_getString(&conf.fd, "logging", "aprs_interval", "60", inibuf, sizeof(inibuf));
	aprs_interval = ms_to_ticks(atoi(inibuf) * 1000);

	ini_getString(&conf.fd, "logging", "log_interval", "3", inibuf, sizeof(inibuf));
	log_interval = ms_to_ticks(atoi(inibuf) * 1000);

	ini_getString(&conf.fd, "logging", "send_call", "STSP2", inibuf, sizeof(inibuf));
	strncpy(send_call, inibuf, sizeof(send_call));
	send_call[sizeof(send_call) - 1] = '\0';

	kfile_close(&conf.fd);

	logging_init();
	ledr(false);
}

int main(void)
{
	init();
	bool led_on = true;

	ticks_t aprs_start = timer_clock();
	ticks_t log_start = timer_clock();
	while (1)
	{
		timer_delay(500);

		bool fix = gps_fixed();

		if (fix && led_on)
			ledg(true);
		else if (!fix && led_on)
			ledr(true);
		else
		{
			ledg(false);
			ledr(false);
		}

		led_on = !led_on;

		if (kbd_peek() & K_START)
		{
			landing_reset();
			cutoff_reset();
			ledg(true);
			ledr(true);
			logging_rotate();
		}

		if (timer_clock() - log_start > log_interval)
		{
			log_start = timer_clock();

			const char *msg = measures_format();
			kprintf("%s", msg);
			logging_data("%s", msg);
		}

		if (timer_clock() - aprs_start > aprs_interval)
		{
			aprs_start = timer_clock();

			const char *msg = measures_format();

			AX25Call path[2]=
			{
				AX25_CALL("APZBRT", 0),
			};
			memcpy(path[1].call, send_call, sizeof(path[1].call));
			path[1].ssid = 0;

			ax25_sendVia(&ax25, path, countof(path), msg, strlen(msg));
		}
	}
	return 0;
}

